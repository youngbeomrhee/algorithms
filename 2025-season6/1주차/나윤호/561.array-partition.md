# LeetCode 561. Array Partition

- 처음에는 for 문 2개를 nums 길이만큼 순회하면서 풀려고함
- 정렬이 되지 않은 상태에서 그냥 순회하면서 비교로만 pair를 만드는건 불가능하였고 문제에 부합하느 값을 얻을 수가 없었음
- Claude Code를 사용해서 사람이 생각하듯이 접근해달라고 요청하여 정렬의 힌트를 얻음

그래서 최종적으로 `o(n log n)` 시간 복잡도를 가짐
```typescript
function arrayPairSum(nums: number[]): number {
    const sorted = nums.sort((a, b) => a-b);

    let result = 0;
    for(let i = 0; i < nums.length; i+=2) {
        result += sorted[i];
    }

    return result
};
```

# AI 피드백

## 문제 설명
- `2n`개 정수를 `n`개 쌍으로 그룹핑
- 각 쌍에서 최솟값들의 합을 최대화하는 문제
- 난이도: Easy
- 태그: Array, Greedy, Sorting, Counting Sort

## 예시
```
Input: nums = [1,4,3,2]
Output: 4
설명: (1,2), (3,4) → min(1,2) + min(3,4) = 1 + 3 = 4
```

## 핵심 통찰
1. **그리디 접근**: 큰 수를 희생하더라도 최솟값을 최대한 크게 만들어야 함
2. **정렬의 필요성**: 배열을 정렬하면 최적 패턴이 보임
3. **패턴 발견**: 정렬 후 짝수 인덱스(0,2,4...)의 원소들이 답

## 해결 단계
1. **정렬**: `nums.sort((a, b) => a - b)`로 오름차순 정렬
2. **패턴 적용**: 정렬된 배열에서 인덱스 0, 2, 4, ... 원소들만 더하기
3. **이유**: `(a,b)` 쌍에서 `a ≤ b`일 때, `min(a,b) = a`

## 코드 구현

### 초기 버전 (개선 필요)
```typescript
function arrayPairSum(nums: number[]): number {
    const sorted = nums.sort((a, b) => a-b);
    
    let result = 0;
    for(let i = 0; i < nums.length; i+=2) {
        result += Math.min(sorted[i], sorted[i +1]); // ❌ 불필요한 Math.min
    }
    
    return result;
}
```

### 최적화된 버전
```typescript
function arrayPairSum(nums: number[]): number {
    const sorted = nums.sort((a, b) => a-b);
    
    let result = 0;
    for(let i = 0; i < nums.length; i+=2) {
        // 정렬했으므로 첫 번째가 항상 더 작음
        result += sorted[i]; // ✅ 최적화됨
    }
    
    return result;
}
```

## 코드 개선 포인트

### 1. 정렬 함수 명시
- ✅ `nums.sort((a, b) => a - b)` - 숫자 정렬

### 2. 불필요한 연산 제거
- 정렬 후 `sorted[i] ≤ sorted[i+1]` 보장
- `Math.min()` 대신 `sorted[i]` 직접 사용

### 3. 메모리 최적화
- 새 배열 생성 대신 원본 배열 정렬 가능
- 공간복잡도 O(1)로 개선

## 그리디 알고리즘 분석

### 그리디 알고리즘이란?
각 단계에서 그 순간 최적인 선택을 하는 알고리즘
- "탐욕적"으로 당장 가장 좋아 보이는 것을 선택
- 지역 최적해를 통해 전역 최적해 추구

### 그리디 알고리즘 조건
1. **그리디 선택 속성**: 각 단계의 최적 선택이 전체 최적해로 이어짐
2. **최적 부분 구조**: 전체 문제의 최적해가 부분 문제의 최적해로 구성됨

### Array Partition에서의 그리디 적용
- **그리디 선택**: 정렬 후 짝수 인덱스만 선택
- **최적성 증명**: 인접한 원소끼리 쌍을 만들면 최대한 큰 최솟값 확보

## 복잡도 분석
- **시간복잡도**: O(n log n) - 정렬 때문
- **공간복잡도**: O(1) - 추가 공간 불필요 (원본 배열 정렬 시)

## 다른 접근법과 비교

| 접근법 | 시간복잡도 | 공간복잡도 | 최적해 보장 |
|--------|------------|------------|-------------|
| 그리디 (정렬) | O(n log n) | O(1) | ✅ |
| 완전탐색 | O(2^n) | O(n) | ✅ |
| Counting Sort | O(n + k) | O(k) | ✅ |

## 학습 포인트

### 1. 패턴 인식 능력
- "정렬 후 홀수번째 인덱스" 패턴 발견
- 왜 이 패턴이 최적인지 수학적 이해

### 2. 그리디 알고리즘 사고
- 지역 최적해가 전역 최적해가 되는 이유
- 반례가 없는지 검증하는 과정

### 3. 코딩 테스트 관점
- **엣지 케이스**: 빈 배열, 음수, 중복값
- **코드 가독성**: 변수명, 주석, 의도 명확화
- **다양한 해법**: Counting Sort 적용 가능성

## 관련 문제들
- Minimum Difference Between Highest and Lowest of K Scores
- Minimum Cost of Buying Candies With Discount
- All Divisions With the Highest Score of a Binary Array

## 핵심 교훈
이 문제는 **그리디 + 정렬**의 전형적인 예시로, 정렬 후 패턴을 찾는 것이 핵심입니다. 
단순한 문제 풀이를 넘어 **알고리즘적 사고력**과 **코딩 실력**을 동시에 향상시킬 수 있는 좋은 문제입니다.